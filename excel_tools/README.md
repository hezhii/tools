# Excel Tools

一个高性能的 Rust 命令行工具，提供 Excel 文件处理功能。

## 功能特性

### 1. 列名检查
- 🔍 检测 Excel 文件中未被系统识别的列名
- 📊 支持多种 Excel 格式：`.xlsx`、`.xls`、`.xlsm`
- 🔄 递归扫描：自动扫描指定目录及其子目录下的所有 Excel 文件
- 🎨 彩色输出：使用彩色终端输出，易于阅读
- 📝 详细模式：可选的详细输出模式，显示每个文件的未识别列名
- ✅ 完整报告：汇总所有未识别的列名

### 2. 格式转换
- 🔄 将 `.xls` 文件批量转换为 `.xlsx` 格式
- 📁 保持目录结构：输出文件维持原始的目录层次
- 📋 多工作表支持：完整保留所有工作表和数据
- 🚀 高性能处理：快速处理大量文件

### 3. 问题文件修复
- 🔧 格式修复：另存 Excel 文件，解决 ExcelJS 解析时的 "attribute without value" 错误
- ✂️ 大文件拆分：将超大 Excel 文件拆分为多个小文件（默认每 6 万行一个文件）
- 📋 JSON 配置：通过 JSON 文件指定需要处理的问题文件列表
- 📂 分类输出：格式修复和拆分文件分别输出到不同目录

## 安装

### 方法 1: 从源码构建（推荐）

确保已安装 Rust 和 Cargo（推荐使用 [rustup](https://rustup.rs/)）

```bash
# 克隆或进入项目目录
cd excel_tools

# 构建发布版本
cargo build --release

# 可执行文件位于 target/release/excel_tools
```

### 方法 2: 直接运行

如果只想临时使用，可以用 `cargo run` 命令：

```bash
cargo run --release -- --input /path/to/excel/folder
```

## 使用方法

本工具提供两个主要功能，通过子命令访问：

### 功能 1: 检查列名 (check)

检测 Excel 文件中未被系统识别的列名。

#### 基本用法

```bash
# 使用编译后的可执行文件
./target/release/excel_tools check --input /path/to/excel/folder

# 或者添加到 PATH 后直接使用
excel_tools check --input /path/to/excel/folder
```

#### 详细输出模式

使用 `-v` 或 `--verbose` 参数启用详细输出：

```bash
excel_tools check --input /path/to/excel/folder --verbose
```

### 功能 2: 格式转换 (convert)

将 `.xls` 文件批量转换为 `.xlsx` 格式，保持原有目录结构。

#### 基本用法

```bash
# 转换 input 目录下的所有 xls 文件到 output 目录
excel_tools convert --input /path/to/input --output /path/to/output
```

#### 参数说明

- `--input, -i`: 输入目录路径（包含 .xls 文件）
- `--output, -o`: 输出目录路径（转换后的 .xlsx 文件保存位置）

### 功能 3: 问题文件修复 (fix)

处理问题文件：修复格式问题和拆分大文件。

#### 基本用法

```bash
# 处理问题文件，输出到指定目录
excel_tools fix --input /path/to/problem_file.json --output /path/to/output
```

#### 自定义拆分行数

```bash
# 每 50000 行拆分一个文件
excel_tools fix --input /path/to/problem_file.json --output /path/to/output --max-rows 50000
```

#### 参数说明

- `--input, -i`: 问题文件 JSON 文件路径
- `--output, -o`: 输出目录路径
- `--max-rows, -m`: 拆分文件时每个文件的最大行数（默认 60000）

#### JSON 文件格式

```json
{
  "file_format": [
    "/path/to/file1.xlsx",
    "/path/to/file2.xlsx"
  ],
  "file_size": [
    "/path/to/large_file1.xlsx",
    "/path/to/large_file2.xlsx"
  ]
}
```

- `file_format`: 格式问题文件列表，这些文件会被另存为新格式，解决 ExcelJS 解析时的 "attribute without value" 错误
- `file_size`: 大文件列表，这些文件会被拆分为多个小文件

#### 输出目录结构

```
output/
├── file_format/          # 格式修复后的文件
│   ├── file1.xlsx
│   └── file2.xlsx
└── file_size/            # 拆分后的文件
    ├── large_file1_split_1.xlsx
    ├── large_file1_split_2.xlsx
    ├── large_file2_split_1.xlsx
    └── large_file2_split_2.xlsx
```

### 查看帮助信息

```bash
# 查看主帮助
excel_tools --help

# 查看 check 子命令帮助
excel_tools check --help

# 查看 convert 子命令帮助
excel_tools convert --help

# 查看 fix 子命令帮助
excel_tools fix --help
```

## 使用示例

### 示例 1: 检查列名 - 基本检测

```bash
$ excel_tools check --input ./data

================================================================================
检测未被系统识别的列名
================================================================================

✓ 找到 3 个 Excel 文件

[1/3] 处理: file1.xlsx
  → 发现 2 个未识别列名
[2/3] 处理: file2.xlsx
  → 所有列名均已识别
[3/3] 处理: subfolder/file3.xlsx
  → 发现 1 个未识别列名

================================================================================
汇总结果
================================================================================

共发现 3 个未被系统识别的列名:

  • 自定义字段1
  • 自定义字段2
  • 备注信息

================================================================================
```

### 示例 2: 检查列名 - 详细输出模式

```bash
$ excel_tools check --input ./data --verbose

================================================================================
检测未被系统识别的列名
================================================================================

✓ 找到 3 个 Excel 文件

[1/3] 处理: file1.xlsx
  → 发现 2 个未识别列名: 自定义字段1, 自定义字段2
[2/3] 处理: file2.xlsx
  → 所有列名均已识别
[3/3] 处理: subfolder/file3.xlsx
  → 发现 1 个未识别列名: 备注信息

================================================================================
汇总结果
================================================================================

共发现 3 个未被系统识别的列名:

  • 自定义字段1
  • 自定义字段2
  • 备注信息

详细信息:

  file1.xlsx
    - 自定义字段1
    - 自定义字段2

  subfolder/file3.xlsx
    - 备注信息

================================================================================
```

### 示例 3: 格式转换

```bash
$ excel_tools convert --input ./old_files --output ./new_files

================================================================================
将 xls 文件转换为 xlsx 格式
================================================================================

✓ 找到 5 个 xls 文件
✓ 输出目录: "./new_files"

[1/5] 转换: data.xls
  ✓ 成功: "data.xlsx"
[2/5] 转换: reports/2023/report.xls
  ✓ 成功: "reports/2023/report.xlsx"
[3/5] 转换: reports/2024/report.xls
  ✓ 成功: "reports/2024/report.xlsx"
[4/5] 转换: archive/old_data.xls
  ✓ 成功: "archive/old_data.xlsx"
[5/5] 转换: backup/file.xls
  ✓ 成功: "backup/file.xlsx"

================================================================================
转换结果统计
================================================================================

成功: 5 个文件
失败: 0 个文件
总计: 5 个文件

输出目录: "./new_files"

================================================================================
```

**目录结构示例：**

转换前 (old_files):
```
old_files/
├── data.xls
├── reports/
│   ├── 2023/
│   │   └── report.xls
│   └── 2024/
│       └── report.xls
├── archive/
│   └── old_data.xls
└── backup/
    └── file.xls
```

转换后 (new_files):
```
new_files/
├── data.xlsx
├── reports/
│   ├── 2023/
│   │   └── report.xlsx
│   └── 2024/
│       └── report.xlsx
├── archive/
│   └── old_data.xlsx
└── backup/
    └── file.xlsx
```

### 示例 4: 问题文件修复

```bash
$ excel_tools fix --input ./problem_file.json --output ./fixed

================================================================================
处理问题文件
================================================================================

✓ 读取问题文件列表成功
  - 格式问题文件: 3 个
  - 需要拆分的文件: 2 个

--------------------------------------------------------------------------------
处理格式问题文件 (另存为新格式)
--------------------------------------------------------------------------------

[1/3] 处理: file1.xlsx
  ✓ 成功保存到: "file1.xlsx"
[2/3] 处理: file2.xlsx
  ✓ 成功保存到: "file2.xlsx"
[3/3] 处理: file3.xlsx
  ⚠️ 文件不存在，跳过

格式修复统计: 成功 2 个, 失败 1 个

--------------------------------------------------------------------------------
处理大文件 (每 60000 行拆分)
--------------------------------------------------------------------------------

[1/2] 拆分: 河北.xlsx
  总数据行数: 150000, 将拆分为 3 个文件
  ✓ 成功拆分为 3 个文件
[2/2] 拆分: 广东.xlsx
  总数据行数: 80000, 将拆分为 2 个文件
  ✓ 成功拆分为 2 个文件

大文件拆分统计: 成功 2 个源文件, 生成 5 个拆分文件, 失败 0 个

================================================================================
处理完成
================================================================================

输出目录:
  - 格式修复文件: "./fixed/file_format"
  - 拆分文件: "./fixed/file_size"

================================================================================
```

**输出目录结构：**

```
fixed/
├── file_format/
│   ├── file1.xlsx
│   └── file2.xlsx
└── file_size/
    ├── 河北_split_1.xlsx
    ├── 河北_split_2.xlsx
    ├── 河北_split_3.xlsx
    ├── 广东_split_1.xlsx
    └── 广东_split_2.xlsx
```

## 系统识别的列名

工具内置了以下系统列名的识别规则（部分列表）：

- 标题、申请人、公开(公告)号、摘要、申请号、申请日
- 专利类型、IPC主分类、IPC、CPC
- 发明人、当前权利人、代理机构、代理人
- 引证次数、被引证次数、家族同族信息
- 法律状态、转让信息、许可信息、质押信息
- 更多...（共 190+ 个系统列名）

完整列表请查看源代码中的 `get_system_columns()` 函数。

## 技术栈

- **语言**: Rust
- **依赖库**:
  - `calamine`: Excel 文件读取（支持 .xls 和 .xlsx）
  - `rust_xlsxwriter`: Excel 文件写入（生成 .xlsx）
  - `walkdir`: 递归目录遍历
  - `clap`: 命令行参数解析
  - `colored`: 彩色终端输出

## 性能特点

- 采用 Rust 开发，编译后的二进制文件执行效率极高
- 内存安全，无需垃圾回收
- 并发友好的架构设计
- 适合处理大量 Excel 文件

## 常见问题

### Q: 支持哪些 Excel 格式？
A: 
- **检查列名功能**: 支持 `.xlsx`、`.xls` 和 `.xlsm` 格式
- **格式转换功能**: 将 `.xls` 转换为 `.xlsx` 格式

### Q: 转换时会保留原始文件吗？
A: 是的，转换功能只读取输入目录的文件，所有转换后的文件保存到输出目录，不会修改原始文件。

### Q: 转换时目录结构会保留吗？
A: 是的，输出目录会完整保留输入目录的子目录结构。

### Q: 如何添加新的系统列名？
A: 编辑 `src/main.rs` 文件中的 `get_system_columns()` 函数，在列表中添加新的列名即可。

### Q: 程序报错无法读取某个文件？
A: 可能是文件损坏或格式不标准，程序会跳过该文件并继续处理其他文件。

### Q: 转换大文件时速度慢怎么办？
A: Rust 的性能已经很高，但处理超大文件时仍需要一些时间。可以考虑先转换小批量文件测试。

### Q: 如何让工具在系统任意位置都能使用？
A: 参考 [BUILD.md](BUILD.md) 文档，将编译后的可执行文件添加到系统 PATH。

## 许可证

MIT License

## 贡献

欢迎提交 Issue 和 Pull Request！
